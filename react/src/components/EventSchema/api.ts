import { Schema, SchemaField, SchemaKey } from './types';
import { fetcher } from '../Api/fetcher';
import _set from 'lodash/set';
import _merge from 'lodash/merge';
import _omit from 'lodash/omit';
import _unset from 'lodash/unset';

export const BASE_URL = '/api/v1/events';

export const apiPaths = {
  SCHEMAS: '/schemas',
  SCHEMA: (schemaKey: SchemaKey, version: string) =>
    `/schema/${schemaKey}?version=${version}`,
  PROPERTIES: (URI: string) => `/schemas/properties/${URI}`,
};

export const fetchSchemas = async (
  url: string,
): Promise<{ schemas: Schema[] }> => {
  const schemas = await fetcher
    .get<Schema[]>(`${url}${apiPaths.SCHEMAS}`)
    .then(({ data }) => data);
  return { schemas };
};

export const fetchSchema = async (
  schemaKey: SchemaKey,
  version: string,
): Promise<Schema> => {
  const encodedKey = encodeURIComponent(schemaKey);
  const encodedVersion = encodeURIComponent(version);
  return fetcher
    .get(`${BASE_URL}${apiPaths.SCHEMA(encodedKey, encodedVersion)}`)
    .then(({ data }) => data);
};

export const fetchProperties = async (URI: string): Promise<any> => {
  const encodedURI = encodeURIComponent(URI);
  return fetcher
    .get(`${BASE_URL}${apiPaths.PROPERTIES(encodedURI)}`)
    .then(({ data }) => data);
};

/**
 * shouldParseAsDirectRef
 * Checks if nested properties of a Fields should be identified as if its own
 * properties. Most noticeable for "date" derived and "@id" attributes.
 * TODO move this logic to the API
 */
const shouldParseAsDirectRef = (field: SchemaField, properties: any[]) => {
  return properties.length === 1 && field.name !== properties[0].name;
};

/**
 * shouldParseAsEnumRef
 * Checks if nested  properties of a Fields should be identified as
 * derived from a enum ref. The typeList is generated by the api but it still
 * remains in the nested "properties" attribute. Most noticeable for "intent"
 * attribute.
 * TODO move this logic to the API
 */
const shouldParseAsEnumRef = (properties: any[]) => {
  return properties.length === 1 && Array.isArray(properties[0].typeList);
};

/**
 * shouldParseAsOneOfRef
 * Checks if nested  properties of a Fields should be identified as
 * derived from a ref that points to a collection of objects. Most noticeable
 * for "object" and "target" attribute.
 * TODO move this logic to the API
 */
const shouldParseAsOneOfRef = (properties: any[]) => {
  return (
    properties.length === 1 &&
    properties[0].type === 'object' &&
    Array.isArray(properties[0].properties)
  );
};

/**
 * shouldParseAsDirectProperties
 * Checks if nested  properties of a Fields should be identified as direct, having
 * just an undesired in-between property .
 * TODO move this logic to the API
 */
const shouldParseAsDirectProperties = (
  properties: any[],
  field: SchemaField,
) => {
  return (
    properties.length === 1 &&
    properties[0].type === 'object' &&
    Array.isArray(properties[0].properties) &&
    properties[0].name === field.name
  );
};

/**
 * flattenFieldRef
 * Inspects a Field object and parses its "properties" attribute and incorporates
 * it depending if they have being generated from a direct $ref, an enum $ref or
 * a oneOf $ref by the API
 * TODO move this logic to the API
 */
export const flattenFieldRef = (field: SchemaField): SchemaField => {
  if (Array.isArray(field?.properties) && !field._mutated) {
    if (shouldParseAsDirectProperties(field.properties, field)) {
      _set(field, 'properties', field.properties[0].properties);
      _set(field, '_mutated', true);
    }
    if (shouldParseAsOneOfRef(field.properties)) {
      _set(field, 'isOneOfProperty', true);
      _set(field, 'properties', field.properties[0].properties);
      _set(field, '_mutated', true);
    }
    if (
      shouldParseAsDirectRef(field, field.properties) ||
      shouldParseAsEnumRef(field.properties)
    ) {
      // We should maintain the upper name and id from a field that has
      // actual properties under nested children.
      _merge(field, _omit(field.properties[0], ['id', 'name']));
      _unset(field, 'properties');
      _set(field, '_mutated', true);
    }
  }

  return field;
};
